#!/bin/bash

VERSION=0.3.0

debug=0
verbose=0
quiet=0
sanitycheck=0

do_part=0
do_raid=0
do_lvm=0
do_luks=0
do_makeconf=0
do_kernel=0
do_postnet=0
do_password=0
do_tz=0
do_keymap=0
do_host=0
do_localmounts=0
do_netmounts=0
do_stage_uri=0
do_format=0
do_bootloader=0
do_xpkg=0
do_services=0

trap "failure_cleanup" TERM KILL INT QUIT ABRT

# can't hurt
if [ "$(whoami)" = "root" ]; then
    echo "You must be root"
    exit 1
fi

has() {
    if ( which $1 &>/dev/null ) ; then
        true
    else
        error "$1: core tool missing from livecd!"
        echo "use the package manager to install it"
        echo "or use another livecd." ; exit 1
    fi
}

import() {
    module=$1
    if source modules/${module}.sh &>/dev/null ; then
        true
#    elif source /usr/lib/kicktoo-${VERSION}/modules/${module}.sh ; then
    elif source /usr/share/kicktoo/modules/${module}.sh ; then
        true
    else
        echo "critical error - cannot load modules - exiting!" ; exit 1
    fi
    debug import "imported module ${module}"
}

usage() {
    msg=$1
    [ -n "${msg}" ] && echo -e "${msg}\n"
    
    cat <<EOF
Usage:
    $0 [options] <profile>

Options:
    -h, --help            This
    -v, --verbose         Be verbose (show command output)
    -d, --debug           Output debugging messages
    -q, --quiet           Only output fatal error messages
EOF
#    -s, --sanity-check    Sanity check install profile
#    -c, --client <host>   Act as a client and connect to a kicktoo daemon
    cat <<FOE
    --version             Print version

Parameter:
    profile              Path to an install profile

Tip:
    read profiles/config.txt for all profile features and options

FOE
}

for i in output misc spawn fetcher bootloader partition install_steps config stepcontrol server 
do
    import $i
done

while [ ${#} -gt 0 ]
do
    a=${1}
    shift
    case "${a}" in
        -h|--help)
            usage
            exit 0
            ;;
        -s|--sanity-check)
            sanitycheck=1
            ;;
        -d|--debug)
            debug=1
            ;;
        -q|--quiet)
            if [ ${verbose} = 1 ]; then
                warn "The --quiet and --verbose options are mutually exclusive"
                warn "Last option will prevail"
                verbose=0
            fi
            quiet=1
            ;;
        -v|--verbose)
            if [ ${quiet} = 1 ]; then
                warn "The --quiet and --verbose options are mutually exclusive"
                warn "Last option will prevail"
                quiet=0
            fi
            verbose=1
            ;;
        -c|--client)
            server=${1}
            shift
            ;;
        --version)
            echo "Kicktoo version ${VERSION} based on Quickstart modules from agaffney"
            exit 0
            ;;
        -*)
            usage "You have specified an invalid option: ${a}"
            exit 1
            ;;
        *)
            profile=$a
            ;;
    esac
done

# check for required programs on livecd
for a in bash curl fdisk grep shred egrep mount swapoff swapon mke2fs wget chroot tar whoami hostname partprobe
do  
    has "${a}"
done

if [ -n "${server}" ]; then
    server_init
    server_get_profile && profile="/tmp/kicktoo_profile"
fi

if [ -z "${profile}" ]; then
    usage "You must specify a profile"
    exit 1
fi
if [ ! -f "${profile}" ]; then
    error "Specified profile does not exist!"
    exit 1
fi    

# load profile
source "${profile}"
# profile variables are now accessible
# export  variables are now accessible (i.e. do_luks) from config.sh functions

! touch ${logfile} 2>/dev/null && ( error "Logfile is not writeable!" ; exit 1 )

[ "${do_raid}" == "yes" ]      && has "mdadm"
[ "${do_lvm}"  == "yes" ]      && has "pvcreate"
[ "${do_luks}" == "yes" ]      && has "cryptsetup"
[ -n "$(grep xz ${profile})" ] && has "unxz"

arch=$(get_arch) ; [ -z "${arch}" ] && die "Could not determine system architecture!"

# call sanity_check_config if 'kicktoo -s <profile>' is run and exit
#[ "${sanitycheck}" = "1" ] && ( runstep sanity_check_config "Sanity checking config" ; exit 0 )

debug main "Pushing system for ${arch}"

run_pre_install_script                                                "Running pre-install script if any"

[ "${do_part}"          == "yes" ] && runstep partition               "Partitioning"
[ "${do_raid}"          == "yes" ] && runstep setup_mdraid            "Setting up RAID arrays"
[ "${do_lvm}"           == "yes" ] && runstep setup_lvm               "Setting up LVM volumes"
[ "${do_luks}"          == "yes" ] && runstep luks_devices            "Encrypting devices"
[ "${do_format}"        == "yes" ] && runstep format_devices          "Formatting devices"
[ "${do_localmounts}"   == "yes" ] && runstep mount_local_partitions  "Mounting local partitions"
[ "${do_netmounts}"     == "yes" ] && runstep mount_network_shares    "Mounting network shares"
if [ "${do_stage_uri}"  == "yes" ] || [ "${do_stage_path}" == "yes" ]; then
 runstep fetch_stage_tarball                                          "Fetching stage tarball"
 runstep unpack_stage_tarball                                         "Unpacking stage tarball"
 runstep prepare_chroot                                               "Preparing chroot"
 runstep setup_fstab                                                  "Setting up /etc/fstab"
fi
[ "${do_makeconf}"      == "yes" ] && runstep create_makeconf         "Creating custom make.conf"
[ "${do_tree}"          == "yes" ] && runstep fetch_repo_tree         "Fetching repository tree"
[ "${do_tree}"          == "yes" ] && runstep unpack_repo_tree        "Unpacking repository tree"
[ "${do_kbin}"          == "yes" ] && runstep copy_kernel             "Copying precompiled kernel"
[ "${do_kernel}"        == "yes" ] && runstep build_kernel            "Building kernel"
[ "${do_postnet}"       == "yes" ] && runstep setup_network_post      "Setting up post-install networking"
[ "${do_password}"      == "yes" ] && runstep setup_root_password     "Setting up root password"
[ "${do_tz}"            == "yes" ] && runstep setup_timezone          "Setting up timezone"
[ "${do_keymap}"        == "yes" ] && runstep setup_keymap            "Setting up keymap"
[ "${do_host}"          == "yes" ] && runstep setup_host              "Setting up hostname"
[ "${do_bootloader}"    == "yes" ] && runstep install_bootloader      "Compiling bootloader"
[ "${do_bootloader}"    == "yes" ] && runstep configure_bootloader    "Configuring bootloader"
[ "${do_xpkg}"          == "yes" ] && runstep install_extra_packages  "Compiling extra packages"
[ "${do_services}"      == "yes" ] && runstep add_and_remove_services "Adding and removing services"

runstep run_post_install_script                                       "Running post-install script if any"
runstep finishing_cleanup                                             "Cleaning up"

#####################################################################
# FIXME this takes care of umounting a second time ${chroot_dir}/boot
#       $(mount) does not show it but $(cat /proc/mounts) does, WTF?!
if [ -n "$(cat /proc/mounts | grep ${chroot_dir}/boot)" ]; then     #
    umount ${chroot_dir}/boot                                       #
fi                                                                  #
#####################################################################

notify                                                                "Install complete!"

[ "${reboot}" == "yes" ] && notify                                    "Rebooting..."
[ "${reboot}" == "yes" ] && reboot
